# Writeup 3 - Operational Security and Social Engineering

Name: Linda
Section: 0201

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examination.

Digital acknowledgement: Linda Yeung

## Assignment Writeup

### Part 1 (40 pts)
The flag is CMSC389R-{d1gging_f0r_flag5_thr0ugh_1njec7ion}.
The input to obtain the flag is "; cd home; cat flag.txt".
When we netcat the server, it prompts us for a user input. Because the server does not check to escape special characters in the input, we can construct one such that our input will be read as code instead of text. We add the semi-colon to "trick" the server into thinking that the command for the user input has completed at this point, and then we add on additional shell command which will now be code on the server-side.  I then input another command, 'ls', which lists the contents in a directory. From the root level folder, ls gave us a list of directories. Most likely user files are stored in home. I then constructed another input to the server, the linux command cd, which changes directory, to change directory into home. I appended ls to that and separated those with a semi-colon so the server command-line knows that its two separate commands, and as a result was able to list the contents of the home directory. It was there that I saw that within the home directory there was the flag.txt. The linux command 'cat' allows us the view the contents of a file. Thus, this time not only did i cd into home, but I also cat the flag.txt file which I saw earlier from calling ls in the home directory. This is where I found the flag. Basically with each semi-colon, we can construct a string of command to traverse the file system on that server, all through the principles of command-line injection.
In order for v0idcache to prevent this vulnerability, she should sanitize user inputs. In particular, escape semi-colons so that it is not treated as code. This may still be vulnerable and would require detailed sanitization. She may choose to whitelist inputs, rejecting any inputs that are not listed, but the trade-off is that it is impossible to capture every possible domain users hope to "DiG". Thus, I would recommend just escaping semi-colons and any characters that cannot be present in URL or domains, so we limit the restriction on user inputs while still ensuring that users cannot insert special characters that will be treated as code.

### Part 2 (60 pts)

Our stub.py program will allow the users to select from a list of options how they wish to interact with the remote server we have managed to hack into. Users have four options: shell, pull, help, and quit. To enter the shell option, users should input "shell". The shell will spawn a shell which conveniently allows users to navigate the file system on the remote server, as well as perform any linux command on it without having the go through the hassle of constructing a string of command-line injections every time. The shell keeps track of the current directory by storing changes in path in an array called history, and will change to the appropriate directory before executing the next shell command. When users wish to exit the shell on the remote system to return back to the prompt for our service, they just need to input "quit". This will bring them back to the main menu. The user can alternatively pull files to a location on the host system by specifying "pull" followed by a path to a file on the remote system with which they wish to pull from, and a path on the host system with which they want to "download" the contents to. If the file does not currently exist in the path on host system, it will be created and the contents will be inserted there. Users can input 'help' to bring up the four options in case they were confused. When users are done and would like to exit the program, they should input 'quit'. This will conclude the program. If at any point the user inputs a malformed input or an unrecognized input, the list of four options will show up again for their convenience. This includes malformed pull requests: requests must begin will pulled followed by a space and then two specified locations, each separated with a space. If only one location was specified or too many locations were specified, the pull request will not be made at this time.
